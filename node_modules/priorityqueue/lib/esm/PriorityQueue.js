function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/* eslint-disable class-methods-use-this */
import { defaultComparator } from "./comparator";
/**
 * Option structure of Priority Queue.
 */

/**
 * An Abstract class of Priority Queue.
 */
export var PriorityQueue =
/*#__PURE__*/
function () {
  _createClass(PriorityQueue, null, [{
    key: "from",

    /**
     * Build priority queue from given array.
     */
    value: function from(_array, _option) {
      throw new Error("not implemented");
    }
    /**
     * Constructor of Priority Queue, with the given 'comparator'.
     * 'comparator' should be same as Array.prototype.sort's argument.
     * Like this: (a, b) => (a == b ? 0 : (a < b ? -1 : 1));
     * If not, default function will be passed by PriorityQueue entrypoint.
     */

  }]);

  function PriorityQueue() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$comparator = _ref.comparator,
        comparator = _ref$comparator === void 0 ? defaultComparator : _ref$comparator;

    _classCallCheck(this, PriorityQueue);

    _defineProperty(this, "comparator", void 0);

    this.comparator = comparator;
  }
  /**
   * Clear this priority queue.
   */


  _createClass(PriorityQueue, [{
    key: "clear",
    value: function clear() {
      throw new Error("not implemented");
    }
    /**
     * Write out the priority queue content as an Array.
     */

  }, {
    key: "toArray",
    value: function toArray() {
      throw new Error("not implemented");
    }
    /**
     * Returns size of the priority queue.
     */

  }, {
    key: "push",

    /**
     * Push the element to the priority queue and returns self.
     */
    value: function push(_value) {
      throw new Error("not implemented");
    }
    /**
     * Enqueue the element to the priority queue and returns self. Alias of push().
     */

  }, {
    key: "enqueue",
    value: function enqueue(value) {
      return this.push(value);
    }
    /**
     * Get the top element of the priority queue.
     */

  }, {
    key: "top",
    value: function top() {
      throw new Error("not implemented");
    }
    /**
     * Peek the top element of the priority queue. Alias of top().
     */

  }, {
    key: "peek",
    value: function peek() {
      return this.top();
    }
    /**
     * Pop the top element of the priority queue.
     */

  }, {
    key: "pop",
    value: function pop() {
      throw new Error("not implemented");
    }
    /**
     * Dequeue the top element of the priority queue. Alias of pop().
     */

  }, {
    key: "dequeue",
    value: function dequeue() {
      return this.pop();
    }
    /**
     * Merge another priority queue into this.
     */

  }, {
    key: "merge",
    value: function merge(_other) {
      throw new Error("not implemented");
    }
    /**
     * Returns the priority queue is empty or not.
     */

  }, {
    key: "isEmpty",
    value: function isEmpty() {
      throw new Error("not implemented");
    }
  }, {
    key: "length",
    get: function get() {
      throw new Error("not implemented");
    }
  }]);

  return PriorityQueue;
}();